<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>× ×—×©×• ××ª ×”×©× ğŸ‘¶</title>
<link href="https://fonts.googleapis.com/css2?family=Heebo:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #121213;
    --tile-border: #3a3a3c;
    --tile-correct: #538d4e;
    --tile-present: #b59f3b;
    --tile-absent: #3a3a3c;
    --text: #ffffff;
    --text-muted: #818384;
    --key-bg: #818384;
    --header-border: #3a3a3c;
    --modal-bg: #1a1a1b;
    --pink: #e4789a;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  html, body {
    height: 100%;
    height: 100dvh;
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Heebo', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow: hidden; /* no scroll â€” everything fits in viewport */
  }

  /* â”€â”€ Header â”€â”€ */
  header {
    width: 100%;
    flex-shrink: 0;
    padding: 10px 16px 8px;
    border-bottom: 1px solid var(--header-border);
    text-align: center;
  }
  header h1 { font-size: clamp(1.1rem, 4vw, 1.5rem); font-weight: 900; color: var(--pink); }
  header p  { font-size: clamp(0.65rem, 2.5vw, 0.78rem); color: var(--text-muted); margin-top: 2px; }

  /* â”€â”€ Toast â”€â”€ */
  #toast-container {
    position: fixed;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    pointer-events: none;
  }
  .toast {
    background: var(--text);
    color: var(--bg);
    padding: 8px 18px;
    border-radius: 6px;
    font-weight: 700;
    font-size: 0.85rem;
    animation: toastIn 0.2s ease, toastOut 0.3s ease 1.5s forwards;
    white-space: nowrap;
  }
  @keyframes toastIn  { from { opacity:0; transform:translateY(-6px); } to { opacity:1; transform:translateY(0); } }
  @keyframes toastOut { from { opacity:1; } to { opacity:0; } }

  /* â”€â”€ Board â”€â”€ */
  #board-container {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8px 0;
    min-height: 0; /* allow flex shrink */
  }

  #board {
    display: grid;
    grid-template-rows: repeat(4, 1fr);
    gap: 5px;
    /* Size = smaller of: 55vw, 42vh â€” keeps it compact on any phone */
    width: min(55vw, 42vh, 220px);
    height: min(55vw, 42vh, 220px);
  }

  .row {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 5px;
  }

  .tile {
    width: 100%;
    aspect-ratio: 1;
    border: 2px solid var(--tile-border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: clamp(1rem, 4vw, 1.6rem);
    font-weight: 900;
    user-select: none;
  }

  .tile[data-letter] { border-color: #565758; }
  .tile.shake   { animation: shake 0.5s ease; }
  .tile.bounce  { animation: bounce 0.55s ease; }
  .tile.pop     { animation: pop 0.1s ease; }

  @keyframes pop    { 0%,100%{transform:scale(1)} 50%{transform:scale(1.12)} }
  @keyframes shake  { 0%,100%{transform:translateX(0)} 10%,50%,90%{transform:translateX(-4px)} 30%,70%{transform:translateX(4px)} }
  @keyframes bounce { 0%,100%{transform:translateY(0)} 40%{transform:translateY(-18px)} 70%{transform:translateY(-8px)} }
  @keyframes flipReveal {
    0%   { transform:rotateX(0deg); }
    49%  { transform:rotateX(-90deg); }
    50%  { transform:rotateX(-90deg); }
    100% { transform:rotateX(0deg); }
  }

  .tile.reveal  { animation: flipReveal 0.5s ease forwards; }
  .tile.correct { background:var(--tile-correct); border-color:var(--tile-correct); }
  .tile.present { background:var(--tile-present); border-color:var(--tile-present); }
  .tile.absent  { background:var(--tile-absent);  border-color:var(--tile-absent);  }

  /* â”€â”€ Keyboard â”€â”€ */
  #keyboard {
    width: 100%;
    flex-shrink: 0;
    padding: 0 4px env(safe-area-inset-bottom, 8px);
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  .kb-row {
    display: flex;
    justify-content: center;
    gap: 4px;
    padding: 0 2px;
  }

  .key {
    /* Height scales with viewport height so keyboard never overflows */
    height: clamp(38px, 6.5vh, 56px);
    flex: 1;
    min-width: 0; /* allow shrinking */
    padding: 0 2px;
    border: none;
    border-radius: 4px;
    background: var(--key-bg);
    color: var(--text);
    font-family: 'Heebo', sans-serif;
    font-size: clamp(0.75rem, 3vw, 1.05rem);
    font-weight: 700;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.2s;
  }

  .key.wide {
    flex: 1.6;
    font-size: clamp(0.6rem, 2.5vw, 0.8rem);
  }

  .key:active   { opacity: 0.7; }
  .key.correct  { background: var(--tile-correct); }
  .key.present  { background: var(--tile-present); }
  .key.absent   { background: var(--tile-absent);  }

  /* â”€â”€ Modal â”€â”€ */
  #modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.78);
    z-index: 500;
    align-items: center;
    justify-content: center;
  }
  #modal-overlay.show { display: flex; }

  #modal {
    background: var(--modal-bg);
    border: 1px solid var(--header-border);
    border-radius: 16px;
    padding: 28px 24px;
    max-width: 320px;
    width: 88%;
    text-align: center;
    animation: modalIn 0.3s ease;
  }
  @keyframes modalIn { from{transform:scale(0.88);opacity:0} to{transform:scale(1);opacity:1} }

  #modal .emoji      { font-size: 2.6rem; margin-bottom: 8px; }
  #modal h2          { font-size: 1.3rem; font-weight: 900; margin-bottom: 6px; }
  #modal .desc       { color: var(--text-muted); font-size: 0.9rem; line-height: 1.5; margin-bottom: 10px; }
  #modal .answer-word{ font-size: 2.2rem; font-weight: 900; color: var(--pink); margin: 6px 0 4px; }
  #modal .tries-line { font-size: 0.82rem; color: var(--text-muted); margin-bottom: 18px; }

  #play-again {
    padding: 12px;
    background: var(--pink);
    color: white;
    border: none;
    border-radius: 8px;
    font-family: 'Heebo', sans-serif;
    font-weight: 700;
    font-size: 1rem;
    cursor: pointer;
    width: 100%;
    transition: opacity 0.2s;
  }
  #play-again:hover { opacity: 0.85; }
</style>
</head>
<body>

<header>
  <h1>ğŸ‘¶ × ×—×©×• ××ª ×”×©×</h1>
  <p>4 ××•×ª×™×•×ª Â· 4 × ×™×¡×™×•× ×•×ª Â· ×©× ×”×‘×ª ×©× ×•×œ×“×”</p>
</header>

<div id="toast-container"></div>

<div id="board-container">
  <div id="board"></div>
</div>

<div id="keyboard"></div>

<div id="modal-overlay">
  <div id="modal">
    <div class="emoji" id="modal-emoji">ğŸ‰</div>
    <h2 id="modal-title"></h2>
    <div class="desc" id="modal-desc"></div>
    <div class="answer-word" id="modal-word"></div>
    <div class="tries-line" id="modal-tries"></div>
    <button id="play-again">×©×—×§×• ×©×•×‘</button>
  </div>
</div>

<script>
const ANSWER   = '××¨×‘×œ';
const MAX_TRIES = 4;
const WORD_LEN  = 4;

const TO_FINAL   = { '×›':'×š','×':'×','× ':'×Ÿ','×¤':'×£','×¦':'×¥' };
const FROM_FINAL = { '×š':'×›','×':'×','×Ÿ':'× ','×£':'×¤','×¥':'×¦' };

const KB_ROWS = [
  ['×¤','×•','×˜','×','×¨','×§'],
  ['×œ','×—','×™','×¢','×›','×’','×“','×©'],
  ['ENTER','×”','×–','×¡','×‘','×','×¦','×ª','× ','âŒ«']
];

let currentRow = 0, currentCol = 0;
let board = Array.from({length:MAX_TRIES}, () => Array(WORD_LEN).fill(''));
let gameOver = false, keyStates = {};

function baseForm(ch)  { return FROM_FINAL[ch] || ch; }
function getTile(r,c)  { return document.getElementById(`tile-${r}-${c}`); }

function applyFinalForm() {
  if (currentCol === 0) return;
  const idx = currentCol - 1, ch = board[currentRow][idx];
  if (TO_FINAL[ch]) { board[currentRow][idx] = TO_FINAL[ch]; getTile(currentRow,idx).textContent = TO_FINAL[ch]; }
}

function revertFinalFormAt(r, c) {
  const ch = board[r][c];
  if (FROM_FINAL[ch]) { board[r][c] = FROM_FINAL[ch]; getTile(r,c).textContent = FROM_FINAL[ch]; }
}

function buildBoard() {
  const el = document.getElementById('board'); el.innerHTML = '';
  for (let r = 0; r < MAX_TRIES; r++) {
    const row = document.createElement('div'); row.className='row'; row.id=`row-${r}`;
    for (let c = 0; c < WORD_LEN; c++) {
      const t = document.createElement('div'); t.className='tile'; t.id=`tile-${r}-${c}`; row.appendChild(t);
    }
    el.appendChild(row);
  }
}

function buildKeyboard() {
  const el = document.getElementById('keyboard'); el.innerHTML = '';
  KB_ROWS.forEach(keys => {
    const row = document.createElement('div'); row.className='kb-row';
    keys.forEach(k => {
      const btn = document.createElement('button');
      btn.className = 'key' + (k==='ENTER'||k==='âŒ«' ? ' wide' : '');
      btn.textContent = k==='ENTER' ? '××™×©×•×¨' : k;
      btn.dataset.key = k; btn.id = `key-${k}`;
      btn.addEventListener('click', () => handleKey(k));
      row.appendChild(btn);
    });
    el.appendChild(row);
  });
}

document.addEventListener('keydown', e => {
  if (gameOver) return;
  if (e.key==='Enter') handleKey('ENTER');
  else if (e.key==='Backspace') handleKey('âŒ«');
  else if (/^[\u05D0-\u05EA]$/.test(e.key)) handleKey(baseForm(e.key));
});

function handleKey(key) {
  if (gameOver) return;
  if (key==='âŒ«') deleteLetter();
  else if (key==='ENTER') submitGuess();
  else if (/^[\u05D0-\u05EA]$/.test(key)) addLetter(baseForm(key));
}

function addLetter(letter) {
  if (currentCol >= WORD_LEN) return;
  if (currentCol > 0) revertFinalFormAt(currentRow, currentCol-1);
  board[currentRow][currentCol] = letter;
  const tile = getTile(currentRow, currentCol);
  tile.textContent = letter; tile.dataset.letter = letter;
  currentCol++;
  applyFinalForm();
  tile.classList.remove('pop'); void tile.offsetWidth; tile.classList.add('pop');
}

function deleteLetter() {
  if (currentCol <= 0) return;
  revertFinalFormAt(currentRow, currentCol-1);
  currentCol--;
  board[currentRow][currentCol] = '';
  const tile = getTile(currentRow, currentCol);
  tile.textContent = ''; delete tile.dataset.letter;
  applyFinalForm();
}

function submitGuess() {
  if (currentCol < WORD_LEN) { shakeRow(currentRow); showToast('×”××™×œ×” ×§×¦×¨×” ××“×™'); return; }
  const guess = board[currentRow].join('');
  revealRow(currentRow, guess, () => {
    if (guess === ANSWER) {
      bounceRow(currentRow); gameOver = true;
      setTimeout(() => showModal(true, currentRow+1), 700);
    } else {
      currentRow++; currentCol = 0;
      if (currentRow >= MAX_TRIES) { gameOver = true; setTimeout(() => showModal(false), 400); }
    }
  });
}

function revealRow(rowIdx, guess, callback) {
  const ansArr = ANSWER.split(''), guessArr = guess.split('');
  const result = Array(WORD_LEN).fill('absent'), count = {};
  for (let i=0;i<WORD_LEN;i++) {
    if (guessArr[i]===ansArr[i]) result[i]='correct';
    else count[ansArr[i]] = (count[ansArr[i]]||0)+1;
  }
  for (let i=0;i<WORD_LEN;i++) {
    if (result[i]!=='correct') { const ch=guessArr[i]; if(count[ch]>0){result[i]='present';count[ch]--;} }
  }
  for (let i=0;i<WORD_LEN;i++) {
    ((idx,state) => {
      setTimeout(() => {
        const tile = getTile(rowIdx,idx);
        tile.classList.add('reveal');
        setTimeout(() => {
          tile.classList.remove('reveal'); tile.classList.add(state);
          const ch = baseForm(guessArr[idx]);
          const pri = {correct:3,present:2,absent:1};
          if ((pri[state]||0) > (pri[keyStates[ch]]||0)) {
            keyStates[ch]=state;
            const k = document.getElementById(`key-${ch}`);
            if(k){k.classList.remove('correct','present','absent');k.classList.add(state);}
          }
          if (idx===WORD_LEN-1) setTimeout(callback,200);
        },250);
      }, idx*300);
    })(i,result[i]);
  }
}

function shakeRow(r) {
  document.getElementById(`row-${r}`).querySelectorAll('.tile').forEach(t => {
    t.classList.add('shake'); t.addEventListener('animationend',()=>t.classList.remove('shake'),{once:true});
  });
}
function bounceRow(r) {
  document.getElementById(`row-${r}`).querySelectorAll('.tile').forEach((t,i) => {
    setTimeout(()=>{ t.classList.add('bounce'); t.addEventListener('animationend',()=>t.classList.remove('bounce'),{once:true}); },i*120);
  });
}
function showToast(msg) {
  const t = document.createElement('div'); t.className='toast'; t.textContent=msg;
  document.getElementById('toast-container').appendChild(t);
  setTimeout(()=>t.remove(),1900);
}

const WON_MSGS = [
  {emoji:'ğŸŒŸ',title:'××“×”×™×!',      desc:'× ×™×—×©×ª× ×‘× ×™×¡×™×•×Ÿ ×”×¨××©×•×Ÿ â€” ×’××•× ×™×!'},
  {emoji:'ğŸ’•',title:'××¦×•×™×Ÿ!',      desc:'×©× ×™ × ×™×¡×™×•× ×•×ª ×‘×œ×‘×“. ×›×‘×¨ ××•×”×‘×™× ××ª ×”×©×!'},
  {emoji:'ğŸ€',title:'×›×œ ×”×›×‘×•×“!',  desc:'× ×™×—×©×ª×! ×‘×¨×•×›×” ×”×‘××” ×œ×¢×•×œ×, ××¨×‘×œ!'},
  {emoji:'ğŸ˜…',title:'×¤×™×•×•!',       desc:'×‘× ×™×¡×™×•×Ÿ ×”××—×¨×•×Ÿ, ××‘×œ ×”×¦×œ×—×ª×!'},
];
const LOST_MSG = {emoji:'ğŸ’™',title:'×œ× ×”×¤×¢×...',desc:'×œ× × ×™×—×©×ª× ×”×¤×¢×, ××‘×œ ×”×©× ×™×¤×” ×‘×›×œ ××§×¨×” ğŸ’•'};

function showModal(won, tries) {
  const msg = won ? WON_MSGS[tries-1] : LOST_MSG;
  document.getElementById('modal-emoji').textContent  = msg.emoji;
  document.getElementById('modal-title').textContent  = msg.title;
  document.getElementById('modal-desc').textContent   = msg.desc;
  document.getElementById('modal-word').textContent   = 'âœ¨ '+ANSWER+' âœ¨';
  document.getElementById('modal-tries').textContent  = won ? `× ×™×—×©×ª× ×‘-${tries} ××ª×•×š ${MAX_TRIES} × ×™×¡×™×•× ×•×ª` : `×”×ª×©×•×‘×” ×”×™×™×ª×”: ${ANSWER}`;
  document.getElementById('modal-overlay').classList.add('show');
}

document.getElementById('play-again').addEventListener('click', () => {
  document.getElementById('modal-overlay').classList.remove('show');
  currentRow=0; currentCol=0;
  board=Array.from({length:MAX_TRIES},()=>Array(WORD_LEN).fill(''));
  gameOver=false; keyStates={};
  buildBoard();
  document.querySelectorAll('.key').forEach(k=>k.classList.remove('correct','present','absent'));
});

buildBoard();
buildKeyboard();
</script>
</body>
</html>
