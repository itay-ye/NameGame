<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>× ×—×©×• ××ª ×”×©× ğŸ‘¶</title>
<link href="https://fonts.googleapis.com/css2?family=Heebo:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #121213;
    --tile-border: #3a3a3c;
    --tile-correct: #538d4e;
    --tile-present: #b59f3b;
    --tile-absent: #3a3a3c;
    --text: #ffffff;
    --text-muted: #818384;
    --key-bg: #818384;
    --header-border: #3a3a3c;
    --modal-bg: #1a1a1b;
    --pink: #e4789a;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Heebo', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    overflow-x: hidden;
  }

  header {
    width: 100%;
    max-width: 500px;
    padding: 14px 16px 12px;
    border-bottom: 1px solid var(--header-border);
    text-align: center;
  }

  header h1 {
    font-size: 1.5rem;
    font-weight: 900;
    letter-spacing: 1px;
    color: var(--pink);
  }

  header p {
    font-size: 0.78rem;
    color: var(--text-muted);
    margin-top: 3px;
  }

  #toast-container {
    position: fixed;
    top: 76px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    pointer-events: none;
  }

  .toast {
    background: var(--text);
    color: var(--bg);
    padding: 10px 20px;
    border-radius: 6px;
    font-weight: 700;
    font-size: 0.9rem;
    animation: toastIn 0.2s ease, toastOut 0.3s ease 1.5s forwards;
    white-space: nowrap;
  }

  @keyframes toastIn { from { opacity:0; transform:translateY(-8px); } to { opacity:1; transform:translateY(0); } }
  @keyframes toastOut { from { opacity:1; } to { opacity:0; } }

  #board-container {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 16px;
  }

  #board {
    display: grid;
    grid-template-rows: repeat(4, 1fr);
    gap: 5px;
    width: min(280px, 80vw);
    height: min(280px, 80vw);
  }

  .row {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 5px;
  }

  .tile {
    width: 100%;
    aspect-ratio: 1;
    border: 2px solid var(--tile-border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: clamp(1.3rem, 5.5vw, 1.9rem);
    font-weight: 900;
    user-select: none;
  }

  .tile[data-letter] { border-color: #565758; }
  .tile.shake { animation: shake 0.5s ease; }
  .tile.bounce { animation: bounce 0.55s ease; }
  .tile.pop { animation: pop 0.1s ease; }

  @keyframes pop {
    0%,100% { transform: scale(1); }
    50% { transform: scale(1.12); }
  }
  @keyframes shake {
    0%,100% { transform: translateX(0); }
    10%,50%,90% { transform: translateX(-4px); }
    30%,70% { transform: translateX(4px); }
  }
  @keyframes bounce {
    0%,100% { transform: translateY(0); }
    40% { transform: translateY(-22px); }
    70% { transform: translateY(-10px); }
  }
  @keyframes flipReveal {
    0% { transform: rotateX(0deg); }
    49% { transform: rotateX(-90deg); }
    50% { transform: rotateX(-90deg); }
    100% { transform: rotateX(0deg); }
  }

  .tile.reveal { animation: flipReveal 0.5s ease forwards; }
  .tile.correct { background: var(--tile-correct); border-color: var(--tile-correct); }
  .tile.present { background: var(--tile-present); border-color: var(--tile-present); }
  .tile.absent  { background: var(--tile-absent);  border-color: var(--tile-absent);  }

  /* Keyboard */
  #keyboard {
    width: 100%;
    max-width: 500px;
    padding: 0 6px 20px;
    display: flex;
    flex-direction: column;
    gap: 7px;
  }

  .kb-row {
    display: flex;
    justify-content: center;
    gap: 5px;
  }

  .key {
    height: 56px;
    min-width: 40px;
    padding: 0 4px;
    border: none;
    border-radius: 4px;
    background: var(--key-bg);
    color: var(--text);
    font-family: 'Heebo', sans-serif;
    font-size: 1.05rem;
    font-weight: 700;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    max-width: 42px;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.2s;
  }

  .key.wide {
    min-width: 58px;
    max-width: 62px;
    font-size: 0.78rem;
  }

  .key:active { opacity: 0.75; }
  .key.correct { background: var(--tile-correct); }
  .key.present { background: var(--tile-present); }
  .key.absent  { background: var(--tile-absent);  }

  /* Modal */
  #modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.75);
    z-index: 500;
    align-items: center;
    justify-content: center;
  }
  #modal-overlay.show { display: flex; }

  #modal {
    background: var(--modal-bg);
    border: 1px solid var(--header-border);
    border-radius: 16px;
    padding: 32px 28px;
    max-width: 340px;
    width: 90%;
    text-align: center;
    animation: modalIn 0.3s ease;
  }

  @keyframes modalIn { from { transform:scale(0.88); opacity:0; } to { transform:scale(1); opacity:1; } }

  #modal .emoji { font-size: 3rem; margin-bottom: 10px; }
  #modal h2 { font-size: 1.4rem; font-weight: 900; margin-bottom: 8px; }
  #modal .desc { color: var(--text-muted); font-size: 0.95rem; line-height: 1.5; margin-bottom: 12px; }
  #modal .answer-word { font-size: 2.4rem; font-weight: 900; color: var(--pink); margin: 8px 0 4px; }
  #modal .tries-line { font-size: 0.85rem; color: var(--text-muted); margin-bottom: 20px; }

  #play-again {
    padding: 14px;
    background: var(--pink);
    color: white;
    border: none;
    border-radius: 8px;
    font-family: 'Heebo', sans-serif;
    font-weight: 700;
    font-size: 1rem;
    cursor: pointer;
    width: 100%;
    transition: opacity 0.2s;
  }
  #play-again:hover { opacity: 0.85; }

  @media (max-width: 360px) {
    .key { height: 50px; font-size: 0.9rem; min-width: 34px; max-width: 36px; }
    .key.wide { min-width: 52px; max-width: 56px; }
    #board { width: min(260px, 82vw); height: min(260px, 82vw); }
  }
</style>
</head>
<body>

<header>
  <h1>ğŸ‘¶ × ×—×©×• ××ª ×”×©×</h1>
  <p>4 ××•×ª×™×•×ª Â· 4 × ×™×¡×™×•× ×•×ª Â· ×©× ×”×‘×ª ×©× ×•×œ×“×”</p>
</header>

<div id="toast-container"></div>

<div id="board-container">
  <div id="board"></div>
</div>

<div id="keyboard"></div>

<div id="modal-overlay">
  <div id="modal">
    <div class="emoji" id="modal-emoji">ğŸ‰</div>
    <h2 id="modal-title"></h2>
    <div class="desc" id="modal-desc"></div>
    <div class="answer-word" id="modal-word"></div>
    <div class="tries-line" id="modal-tries"></div>
    <button id="play-again">×©×—×§×• ×©×•×‘</button>
  </div>
</div>

<script>
// â”€â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ANSWER = '××¨×‘×œ';
const MAX_TRIES = 4;
const WORD_LEN = 4;

// Regular â†’ final form (applied only at end of word)
const TO_FINAL   = { '×›':'×š', '×':'×', '× ':'×Ÿ', '×¤':'×£', '×¦':'×¥' };
const FROM_FINAL = { '×š':'×›', '×':'×', '×Ÿ':'× ', '×£':'×¤', '×¥':'×¦' };

// Keyboard rows â€” NO final letters, only base forms
const KB_ROWS = [
  ['×¤','×•','×˜','×','×¨','×§'],
  ['×œ','×—','×™','×¢','×›','×’','×“','×©'],
  ['ENTER','×”','×–','×¡','×‘','×','×¦','×ª','× ','âŒ«']
];

// â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentRow = 0;
let currentCol = 0;
let board = Array.from({length: MAX_TRIES}, () => Array(WORD_LEN).fill(''));
let gameOver = false;
let keyStates = {};

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function baseForm(ch) { return FROM_FINAL[ch] || ch; }

function applyFinalForm() {
  if (currentCol === 0) return;
  const idx = currentCol - 1;
  const ch = board[currentRow][idx];
  if (TO_FINAL[ch]) {
    const final = TO_FINAL[ch];
    board[currentRow][idx] = final;
    const tile = getTile(currentRow, idx);
    tile.textContent = final;
  }
}

function revertFinalFormAt(rowIdx, colIdx) {
  const ch = board[rowIdx][colIdx];
  if (FROM_FINAL[ch]) {
    const base = FROM_FINAL[ch];
    board[rowIdx][colIdx] = base;
    const tile = getTile(rowIdx, colIdx);
    tile.textContent = base;
  }
}

function getTile(r, c) { return document.getElementById(`tile-${r}-${c}`); }

// â”€â”€â”€ Build Board â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildBoard() {
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  for (let r = 0; r < MAX_TRIES; r++) {
    const row = document.createElement('div');
    row.className = 'row';
    row.id = `row-${r}`;
    for (let c = 0; c < WORD_LEN; c++) {
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.id = `tile-${r}-${c}`;
      row.appendChild(tile);
    }
    boardEl.appendChild(row);
  }
}

// â”€â”€â”€ Build Keyboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildKeyboard() {
  const kbEl = document.getElementById('keyboard');
  kbEl.innerHTML = '';
  KB_ROWS.forEach(keys => {
    const row = document.createElement('div');
    row.className = 'kb-row';
    keys.forEach(k => {
      const btn = document.createElement('button');
      btn.className = 'key' + (k === 'ENTER' || k === 'âŒ«' ? ' wide' : '');
      btn.textContent = k === 'ENTER' ? '××™×©×•×¨' : k;
      btn.dataset.key = k;
      btn.id = `key-${k}`;
      btn.addEventListener('click', () => handleKey(k));
      row.appendChild(btn);
    });
    kbEl.appendChild(row);
  });
}

// â”€â”€â”€ Input Handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('keydown', e => {
  if (gameOver) return;
  if (e.key === 'Enter') handleKey('ENTER');
  else if (e.key === 'Backspace') handleKey('âŒ«');
  else if (/^[\u05D0-\u05EA]$/.test(e.key)) handleKey(baseForm(e.key));
});

function handleKey(key) {
  if (gameOver) return;
  if (key === 'âŒ«') deleteLetter();
  else if (key === 'ENTER') submitGuess();
  else if (/^[\u05D0-\u05EA]$/.test(key)) addLetter(baseForm(key));
}

function addLetter(letter) {
  if (currentCol >= WORD_LEN) return;
  // Revert previous last letter from final form before adding new letter
  if (currentCol > 0) revertFinalFormAt(currentRow, currentCol - 1);

  board[currentRow][currentCol] = letter;
  const tile = getTile(currentRow, currentCol);
  tile.textContent = letter;
  tile.dataset.letter = letter;
  currentCol++;

  // Apply final form to new last letter
  applyFinalForm();

  // Pop animation
  tile.classList.remove('pop');
  void tile.offsetWidth;
  tile.classList.add('pop');
}

function deleteLetter() {
  if (currentCol <= 0) return;
  // Revert final form on last letter (we're removing it)
  revertFinalFormAt(currentRow, currentCol - 1);
  currentCol--;
  board[currentRow][currentCol] = '';
  const tile = getTile(currentRow, currentCol);
  tile.textContent = '';
  delete tile.dataset.letter;
  // Apply final form to new last letter
  applyFinalForm();
}

function submitGuess() {
  if (currentCol < WORD_LEN) {
    shakeRow(currentRow);
    showToast('×”××™×œ×” ×§×¦×¨×” ××“×™');
    return;
  }

  const guess = board[currentRow].join('');
  revealRow(currentRow, guess, () => {
    if (guess === ANSWER) {
      bounceRow(currentRow);
      gameOver = true;
      setTimeout(() => showModal(true, currentRow + 1), 700);
    } else {
      currentRow++;
      currentCol = 0;
      if (currentRow >= MAX_TRIES) {
        gameOver = true;
        setTimeout(() => showModal(false, MAX_TRIES), 400);
      }
    }
  });
}

// â”€â”€â”€ Reveal Row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function revealRow(rowIdx, guess, callback) {
  const answerArr = ANSWER.split('');
  const guessArr  = guess.split('');
  const result = Array(WORD_LEN).fill('absent');
  const count = {};

  for (let i = 0; i < WORD_LEN; i++) {
    if (guessArr[i] === answerArr[i]) {
      result[i] = 'correct';
    } else {
      count[answerArr[i]] = (count[answerArr[i]] || 0) + 1;
    }
  }
  for (let i = 0; i < WORD_LEN; i++) {
    if (result[i] !== 'correct') {
      const ch = guessArr[i];
      if (count[ch] > 0) { result[i] = 'present'; count[ch]--; }
    }
  }

  for (let i = 0; i < WORD_LEN; i++) {
    ((idx, state) => {
      setTimeout(() => {
        const tile = getTile(rowIdx, idx);
        tile.classList.add('reveal');
        setTimeout(() => {
          tile.classList.remove('reveal');
          tile.classList.add(state);
          // Update keyboard â€” use base form for key lookup
          const ch = baseForm(guessArr[idx]);
          const priority = { correct:3, present:2, absent:1 };
          if ((priority[state] || 0) > (priority[keyStates[ch]] || 0)) {
            keyStates[ch] = state;
            const keyEl = document.getElementById(`key-${ch}`);
            if (keyEl) { keyEl.classList.remove('correct','present','absent'); keyEl.classList.add(state); }
          }
          if (idx === WORD_LEN - 1) setTimeout(callback, 200);
        }, 250);
      }, idx * 300);
    })(i, result[i]);
  }
}

// â”€â”€â”€ Animations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function shakeRow(rowIdx) {
  document.getElementById(`row-${rowIdx}`).querySelectorAll('.tile').forEach(t => {
    t.classList.add('shake');
    t.addEventListener('animationend', () => t.classList.remove('shake'), {once:true});
  });
}

function bounceRow(rowIdx) {
  document.getElementById(`row-${rowIdx}`).querySelectorAll('.tile').forEach((t, i) => {
    setTimeout(() => {
      t.classList.add('bounce');
      t.addEventListener('animationend', () => t.classList.remove('bounce'), {once:true});
    }, i * 120);
  });
}

// â”€â”€â”€ Toast â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showToast(msg) {
  const t = document.createElement('div');
  t.className = 'toast';
  t.textContent = msg;
  document.getElementById('toast-container').appendChild(t);
  setTimeout(() => t.remove(), 1900);
}

// â”€â”€â”€ Modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const WON_MSGS = [
  { emoji: 'ğŸŒŸ', title: '××“×”×™×!',      desc: '× ×™×—×©×ª× ×‘× ×™×¡×™×•×Ÿ ×”×¨××©×•×Ÿ â€” ×’××•× ×™×!' },
  { emoji: 'ğŸ’•', title: '××¦×•×™×Ÿ!',      desc: '×©× ×™ × ×™×¡×™×•× ×•×ª ×‘×œ×‘×“. ×›×‘×¨ ××•×”×‘×™× ××ª ×”×©×!' },
  { emoji: 'ğŸ€', title: '×›×œ ×”×›×‘×•×“!',  desc: '× ×™×—×©×ª×! ×‘×¨×•×›×” ×”×‘××” ×œ×¢×•×œ×, ××¨×‘×œ!' },
  { emoji: 'ğŸ˜…', title: '×¤×™×•×•!',       desc: '×‘× ×™×¡×™×•×Ÿ ×”××—×¨×•×Ÿ, ××‘×œ ×”×¦×œ×—×ª×!' },
];
const LOST_MSG = { emoji: 'ğŸ’™', title: '×œ× ×”×¤×¢×...', desc: '×œ× × ×™×—×©×ª× ×”×¤×¢×, ××‘×œ ×”×©× ×™×¤×” ×‘×›×œ ××§×¨×” ğŸ’•' };

function showModal(won, tries) {
  const msg = won ? WON_MSGS[tries - 1] : LOST_MSG;
  document.getElementById('modal-emoji').textContent = msg.emoji;
  document.getElementById('modal-title').textContent = msg.title;
  document.getElementById('modal-desc').textContent = msg.desc;
  document.getElementById('modal-word').textContent = 'âœ¨ ' + ANSWER + ' âœ¨';
  document.getElementById('modal-tries').textContent = won
    ? `× ×™×—×©×ª× ×‘-${tries} ××ª×•×š ${MAX_TRIES} × ×™×¡×™×•× ×•×ª`
    : `×”×ª×©×•×‘×” ×”×™×™×ª×”: ${ANSWER}`;
  document.getElementById('modal-overlay').classList.add('show');
}

document.getElementById('play-again').addEventListener('click', () => {
  document.getElementById('modal-overlay').classList.remove('show');
  currentRow = 0; currentCol = 0;
  board = Array.from({length: MAX_TRIES}, () => Array(WORD_LEN).fill(''));
  gameOver = false; keyStates = {};
  buildBoard();
  document.querySelectorAll('.key').forEach(k => k.classList.remove('correct','present','absent'));
});

// â”€â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
buildBoard();
buildKeyboard();
</script>
</body>
</html>
